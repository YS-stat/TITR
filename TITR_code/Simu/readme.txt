========================================================Project: TENSOR-BASED INDIVIDUALIZED TREATMENT RULE (TITR)========================================================1. Overview------------------------------------We present implementation for estimation of TITR model. For low-dimensional setting, the estimate is obtained by an alternating update algorithm based on Tucker decomposition. For sparse scenario, estimation is performed using Tucker decomposition with potentially distinct ranks for treatment-free and treatment-related effects, combined with L1-regularization to induce sparsity, and an ADMM-based optimization algorithm.2. File Description------------------------------------- low_d.py: Functions for low-dimensional setting.- sparse_testing.py: Functions for sparse scenario. (bootstrap code)- README.txt: This documentation file.low_d.py:------------------------------------This code includes the following functions:=== tensor_r_tucker(X,c,AX,y,B,C,theta_true,R1,R2,R3,tol,MAX_ITER): tensor regression--- Arguments:   X,AX: tensor covariates, c: vector covariate   y: scalar response   B,C: true tensor coefficients, theta_true: true vector coefficient   R1,R2,R3: predetermined rank   tol: convergence threshold, MAX_ITER: maximum number of iterations--- Return:   (mseB,mseC,mse1,mse2): estimated errors,    (H,CH,theta): the estimated coefficients,    (BIC): Value of BIC.   === generate_data(n,p,R,sigma): generate data--- Arguments:   n: sample size, p: dimension of tensor   R: rank of tensor, sigma: noise level--- Return:   (X,c,AX,y): tensor covariate, vector covariate, tensor covariate and scalar response,   (B,C): true tensor coefficients, (theta_true): true vector coefficient.  === pi_opt(),pi_hat(),pi_random(),pi_notensor(): --- Return average outcome value and corresponding MSEs under different treatment rules.=== select_rank(): select rank for tensor regression by BIC=== replication(): replication of the simulation--- Arguments:    n0: sample size, R0: true rank, p: dimension of tensor, sigma: noise level--- Return:   (mseB,mseC,mse1,mse2): estimated errors,    (np.mean(V_opt),V_hat,V_random,V_notensor): average outcome values under different treatment rules,    (MSE_hat,MSE_random,MSE_notensor): MSEs under different treatment rules,   (R_true): indicator for correct rank estimation.sparse_testing.py:------------------------------------This code includes the following functions:=== ADMM(): ADMM algorithm to compute factor matrix=== tensor_r_lasso(X,c,AX,y,B,C,theta_true,R1,R2,R3,lambda1,lambdaa,seed,tol,MAX_ITER1): tensor regression--- Arguments:   X,AX: tensor covariates, c: vector covariate   y: scalar response   B,C: true tensor coefficients, theta_true: true vector coefficient   R1,R2,R3: predetermined rank   lambda1,lambdaa: tuning parameters(lasso penalty), seed: random seed   tol: convergence threshold, MAX_ITER1: maximum number of iterations--- Return:   (eeB,eeC,ee1,ee2): estimated errors, (H,CH,theta): the estimated coefficients.=== generate_data(): generate true coefficients when dimension=(50,50,2)--- Return:   (B,C): true tensor coefficients, (theta_true): true vector coefficient.=== generate_sample(): generate data sample for given coefficients--- Return   (X,c,AX,y): tensor covariate, vector covariate, tensor covariate and scalar response,=== pi_opt(),pi_hat(),pi_random(),pi_notensor(): --- Return average outcome value and corresponding MSEs under different treatment rules.=== rankgrid(): grid search for different ranks, return corresponding estimation errors and estimated coefficients.=== select_r(): select rank for tensor regression by loss in test set.=== replication(): replication of the simulation--- n0: sample size, sigma: noise level--- Return:    (mseB,mseC,mse1,mse2): estimated errors,     (np.mean(V_opt),V_hat,V_random,V_notensor): average outcome values under different treatment rules,     (MSE_hat,MSE_random,MSE_notensor): MSEs under different treatment rules,    (R_true,R_hat): indicator for correct rank estimation, estimated rank.=========TestingWe use the wild bootstrap to test whether two treatment-related coefficients are equal to zero.=== bootstrap_value():  calculate bootstrap statistics=== generate_data2(), generate_sample2(): generate coefficients and data sample under dimension (10,10,10), rank (2,2,2) and sigma level 0.5.=== replication(): calculate pvalues under different delta